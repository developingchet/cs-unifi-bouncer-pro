name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ── 1. Go tests ─────────────────────────────────────────────────────────────
  test:
    name: Go Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run tests (race detector)
        run: go test -race ./... -count=1 -timeout=120s

  # ── 2. Seccomp profile static validation ────────────────────────────────────
  validate-seccomp:
    name: Validate Seccomp Profile
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get install -y --no-install-recommends jq

      - name: Validate syscall allowlist
        run: bash scripts/validate-seccomp.sh ./security/seccomp-unifi.json

  # ── 3. Seccomp integration test ─────────────────────────────────────────────
  # Builds the real image and runs it under the seccomp profile with all the
  # same security options used in production. The bouncer will exit with a
  # connection error (no real UniFi/LAPI) — that is expected. What must NOT
  # appear is the runc "reopen exec fifo" error, which signals that seccomp
  # blocked the container before the Go binary ran.
  test-seccomp:
    name: Seccomp Integration Test
    runs-on: ubuntu-latest
    needs: validate-seccomp
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - name: Build image (linux/amd64)
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          load: true
          push: false
          tags: cs-unifi-bouncer-test:ci
          build-args: |
            VERSION=ci-seccomp-test
            COMMIT=${{ github.sha }}
            BUILD_DATE=1970-01-01T00:00:00Z

      - name: Run bouncer version under seccomp profile
        run: |
          docker run --rm \
            --security-opt "seccomp:./security/seccomp-unifi.json" \
            --security-opt no-new-privileges:true \
            --cap-drop ALL \
            cs-unifi-bouncer-test:ci \
            version

      - name: Test seccomp profile allows storage open (reconcile --dry-run)
        run: |
          mkdir -p /tmp/seccomp-test-data
          chmod 777 /tmp/seccomp-test-data
          docker run --rm \
            --security-opt "seccomp:./security/seccomp-unifi.json" \
            --security-opt no-new-privileges:true \
            --cap-drop ALL \
            -v /tmp/seccomp-test-data:/data \
            -e DRY_RUN=true \
            -e CROWDSEC_LAPI_KEY=test \
            -e UNIFI_URL=https://192.0.2.1 \
            -e UNIFI_API_KEY=test \
            cs-unifi-bouncer-test:ci reconcile || true
          # reconcile will fail to connect (expected) but must not fail with EPERM
          # A seccomp violation exits 159 (SIGSYS); connection failure exits 1.
          # We assert the exit code is NOT 159:
          EXIT=$?
          if [ "$EXIT" -eq 159 ]; then
            echo "FAIL: seccomp blocked a required syscall (exit 159 = SIGSYS)"
            exit 1
          fi
          echo "OK: exit $EXIT (not a seccomp violation)"
